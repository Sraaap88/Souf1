package com.example.souffleforcetest

import android.graphics.Canvas
import android.graphics.Paint
import android.graphics.Path
import android.graphics.Color
import kotlin.math.*

class PlantLeavesManager(private val plantStem: PlantStem) {
    
    // ==================== DATA CLASSES ====================
    
    data class Leaf(
        val x: Float,
        val y: Float,
        val size: Float,
        val angle: Float,
        val isLeft: Boolean,
        val stemIndex: Int,
        val branchIndex: Int = -1, // -1 pour tige principale
        var growthProgress: Float = 0f,
        val targetProgress: Float = 1f,
        val leafType: LeafType = LeafType.NORMAL
    )
    
    enum class LeafType {
        NORMAL,     // Feuille standard
        SMALL,      // Petite feuille vers le sommet
        BASE        // Feuille de base plus large
    }
    
    // ==================== VARIABLES ====================
    
    private val leaves = mutableListOf<Leaf>()
    private var leavesInitialized = false
    private var leafGrowthStartTime = 0L
    
    // ==================== PARAMÈTRES ====================
    
    private val leafGrowthDuration = 3000L // 3 secondes pour faire pousser toutes les feuilles
    private val baseLeafSize = 45f
    private val minLeafSize = 18f
    private val leafSpacing = 35f // Distance entre les feuilles sur une tige
    private val leafAngleVariation = 25f // Variation d'angle naturelle
    
    // ==================== PEINTURE ====================
    
    private val leafPaint = Paint().apply {
        isAntiAlias = true
        style = Paint.Style.FILL
        color = Color.rgb(60, 140, 60)
    }
    
    private val leafOutlinePaint = Paint().apply {
        isAntiAlias = true
        style = Paint.Style.STROKE
        strokeWidth = 1.5f
        color = Color.rgb(40, 100, 40)
    }
    
    // ==================== FONCTIONS PUBLIQUES ====================
    
    fun initializeLeaves() {
        if (leavesInitialized) return
        
        leaves.clear()
        leafGrowthStartTime = System.currentTimeMillis()
        
        // Créer les feuilles sur la tige principale
        createLeavesOnMainStem()
        
        // Créer les feuilles sur les branches
        createLeavesOnBranches()
        
        leavesInitialized = true
    }
    
    fun updateLeafGrowth() {
        if (!leavesInitialized) return
        
        val currentTime = System.currentTimeMillis()
        val elapsedTime = currentTime - leafGrowthStartTime
        val globalProgress = (elapsedTime / leafGrowthDuration.toFloat()).coerceAtMost(1f)
        
        // Mise à jour progressive des feuilles (de bas en haut)
        for (leaf in leaves) {
            val leafStartDelay = (leaves.indexOf(leaf) * 100f) // 100ms entre chaque feuille
            val leafProgress = ((elapsedTime - leafStartDelay) / (leafGrowthDuration * 0.7f)).coerceIn(0f, 1f)
            
            // Courbe de croissance smooth
            leaf.growthProgress = if (leafProgress > 0f) {
                val smoothProgress = 1f - (1f - leafProgress) * (1f - leafProgress)
                smoothProgress * leaf.targetProgress
            } else 0f
        }
    }
    
    fun drawLeaves(canvas: Canvas) {
        if (!leavesInitialized) return
        
        for (leaf in leaves) {
            if (leaf.growthProgress > 0.05f) {
                drawSingleLeaf(canvas, leaf)
            }
        }
    }
    
    fun resetLeaves() {
        leaves.clear()
        leavesInitialized = false
        leafGrowthStartTime = 0L
    }
    
    fun hasVisibleLeaves(): Boolean {
        return leaves.any { it.growthProgress > 0.05f }
    }
    
    // ==================== FONCTIONS PRIVÉES ====================
    
    private fun createLeavesOnMainStem() {
        val mainStem = plantStem.mainStem
        if (mainStem.size < 3) return
        
        val stemHeight = plantStem.getStemHeight()
        var currentHeight = 15f // Commencer un peu au-dessus de la base
        var leafIndex = 0
        var isLeft = true
        
        while (currentHeight < stemHeight - 30f) { // S'arrêter avant le sommet
            // Trouver le point de tige le plus proche
            val targetY = plantStem.getStemBaseY() - currentHeight
            val stemPoint = findClosestStemPoint(mainStem, targetY)
            
            if (stemPoint != null) {
                val leafSize = calculateLeafSize(currentHeight, stemHeight)
                val leafType = determineLeafType(currentHeight, stemHeight)
                val baseAngle = if (isLeft) -45f else 45f
                val angleVariation = (Math.random() * leafAngleVariation - leafAngleVariation/2).toFloat()
                val finalAngle = baseAngle + angleVariation
                
                // Offset horizontal pour éviter que les feuilles se chevauchent avec la tige
                val horizontalOffset = if (isLeft) -leafSize * 0.3f else leafSize * 0.3f
                val leafX = stemPoint.x + horizontalOffset
                
                val leaf = Leaf(
                    x = leafX,
                    y = targetY,
                    size = leafSize,
                    angle = finalAngle,
                    isLeft = isLeft,
                    stemIndex = mainStem.indexOf(stemPoint),
                    leafType = leafType
                )
                
                leaves.add(leaf)
                leafIndex++
                isLeft = !isLeft // Alterner les côtés
            }
            
            currentHeight += leafSpacing + (Math.random() * 10f - 5f).toFloat() // Variation naturelle
        }
    }
    
    private fun createLeavesOnBranches() {
        for ((branchIndex, branch) in plantStem.branches.withIndex()) {
            if (!branch.isActive || branch.points.size < 3) continue
            
            val branchHeight = branch.currentHeight
            var currentHeight = 10f // Commencer proche de la base de la branche
            var isLeft = branchIndex % 2 == 0 // Alterner selon l'index de la branche
            
            while (currentHeight < branchHeight - 20f) {
                val targetY = plantStem.getStemBaseY() - currentHeight
                val branchPoint = findClosestStemPoint(branch.points, targetY)
                
                if (branchPoint != null) {
                    val leafSize = calculateLeafSize(currentHeight, branchHeight) * 0.8f // Feuilles plus petites sur les branches
                    val leafType = determineLeafType(currentHeight, branchHeight)
                    val baseAngle = if (isLeft) -35f else 35f
                    val angleVariation = (Math.random() * 15f - 7.5f).toFloat()
                    val finalAngle = baseAngle + angleVariation
                    
                    val horizontalOffset = if (isLeft) -leafSize * 0.25f else leafSize * 0.25f
                    val leafX = branchPoint.x + horizontalOffset
                    
                    val leaf = Leaf(
                        x = leafX,
                        y = targetY,
                        size = leafSize,
                        angle = finalAngle,
                        isLeft = isLeft,
                        stemIndex = branch.points.indexOf(branchPoint),
                        branchIndex = branchIndex,
                        leafType = leafType
                    )
                    
                    leaves.add(leaf)
                    isLeft = !isLeft
                }
                
                currentHeight += leafSpacing * 1.2f + (Math.random() * 8f - 4f).toFloat()
            }
        }
    }
    
    private fun findClosestStemPoint(points: List<PlantStem.StemPoint>, targetY: Float): PlantStem.StemPoint? {
        return points.minByOrNull { abs(it.y - targetY) }
    }
    
    private fun calculateLeafSize(currentHeight: Float, totalHeight: Float): Float {
        val heightRatio = currentHeight / totalHeight
        
        return when {
            heightRatio < 0.3f -> baseLeafSize * (0.7f + heightRatio) // Feuilles moyennes à la base
            heightRatio < 0.7f -> baseLeafSize // Feuilles pleines au milieu
            else -> baseLeafSize * (1.3f - heightRatio) // Feuilles qui diminuent vers le sommet
        }.coerceAtLeast(minLeafSize)
    }
    
    private fun determineLeafType(currentHeight: Float, totalHeight: Float): LeafType {
        val heightRatio = currentHeight / totalHeight
        
        return when {
            heightRatio < 0.2f -> LeafType.BASE
            heightRatio > 0.8f -> LeafType.SMALL
            else -> LeafType.NORMAL
        }
    }
    
    private fun drawSingleLeaf(canvas: Canvas, leaf: Leaf) {
        val currentSize = leaf.size * leaf.growthProgress
        if (currentSize < 2f) return
        
        canvas.save()
        canvas.translate(leaf.x, leaf.y)
        canvas.rotate(leaf.angle)
        
        // Dessiner la forme de feuille de marguerite (allongée avec bords lobés)
        val path = createDaisyLeafPath(currentSize, leaf.leafType)
        
        // Remplissage de la feuille
        leafPaint.color = getLeafColor(leaf)
        canvas.drawPath(path, leafPaint)
        
        // Contour de la feuille
        canvas.drawPath(path, leafOutlinePaint)
        
        // Nervure centrale
        drawLeafVein(canvas, currentSize)
        
        canvas.restore()
    }
    
    private fun createDaisyLeafPath(size: Float, leafType: LeafType): Path {
        val path = Path()
        
        // Paramètres selon le type de feuille
        val width = when (leafType) {
            LeafType.BASE -> size * 0.7f
            LeafType.SMALL -> size * 0.5f
            LeafType.NORMAL -> size * 0.6f
        }
        
        val length = size
        val lobeDepth = width * 0.2f // Profondeur des lobes
        val lobeCount = 4 // Nombre de lobes de chaque côté
        
        // Commencer à la base de la feuille
        path.moveTo(0f, 0f)
        
        // Côté droit avec lobes
        for (i in 0..lobeCount) {
            val progress = i.toFloat() / lobeCount
            val y = -length * progress
            val baseX = width * 0.5f * (1f - progress * 0.3f) // Rétrécissement vers le sommet
            
            if (i > 0) {
                // Créer un lobe
                val lobeX = baseX + sin(progress * PI * 2) * lobeDepth * (1f - progress)
                path.lineTo(lobeX.toFloat(), y)
            } else {
                path.lineTo(baseX, y)
            }
        }
        
        // Sommet pointu de la feuille
        path.lineTo(0f, -length)
        
        // Côté gauche avec lobes (symétrique)
        for (i in lobeCount downTo 0) {
            val progress = i.toFloat() / lobeCount
            val y = -length * progress
            val baseX = -width * 0.5f * (1f - progress * 0.3f)
            
            if (i < lobeCount) {
                val lobeX = baseX - sin(progress * PI * 2) * lobeDepth * (1f - progress)
                path.lineTo(lobeX.toFloat(), y)
            } else {
                path.lineTo(baseX, y)
            }
        }
        
        path.close()
        return path
    }
    
    private fun getLeafColor(leaf: Leaf): Int {
        val baseGreen = Color.rgb(60, 140, 60)
        
        // Variation subtile selon le type et la position
        return when (leaf.leafType) {
            LeafType.BASE -> Color.rgb(65, 145, 65) // Légèrement plus clair
            LeafType.SMALL -> Color.rgb(55, 135, 55) // Légèrement plus foncé
            LeafType.NORMAL -> baseGreen
        }
    }
    
    private fun drawLeafVein(canvas: Canvas, size: Float) {
        // Nervure centrale simple
        leafOutlinePaint.strokeWidth = 1f
        canvas.drawLine(0f, 0f, 0f, -size * 0.8f, leafOutlinePaint)
        
        // Nervures secondaires
        leafOutlinePaint.strokeWidth = 0.5f
        val veinCount = 3
        for (i in 1..veinCount) {
            val progress = i.toFloat() / (veinCount + 1)
            val y = -size * progress * 0.7f
            val x = size * 0.15f * sin(progress * PI).toFloat()
            
            canvas.drawLine(-x, y, 0f, y * 1.1f, leafOutlinePaint)
            canvas.drawLine(x, y, 0f, y * 1.1f, leafOutlinePaint)
        }
        
        leafOutlinePaint.strokeWidth = 1.5f // Restaurer l'épaisseur normale
    }
}
